# Laravel Lesson レビュー①

## Todo一覧機能

### Todoモデルのallメソッドで実行しているSQLは何か
SELECT * FROM todos;
（todosテーブルから全てのレコードを取得する）

### Todoモデルのallメソッドの返り値は何か
Illuminate\Database\Eloquent\Collectionクラスのインスタンス
クラスというテンプレートを基にして作られた、実際に操作できる個別のオブジェクト

### 配列の代わりにCollectionクラスを使用するメリットは
Collection クラスのメソッドはメソッドチェーンが可能なため、一連の操作を一行で書くことができコードの可読性が向上する。
また、配列と比較して複雑な操作を簡潔に記述できる。例えば、配列の中で条件に合ったデータを抽出したり、複数の条件でソートしたりするのが簡単にできる。
配列を直接操作するのではなく、オブジェクトとして操作できるためデータの管理が一貫性を持って行える。

filterメソッド コレクションの各アイテムに対して指定した条件を満たすかどうかをチェックし、条件を満たすアイテムのみを含む新しいコレクションを返す。
whereメソッドは、指定したキーと値に一致するアイテムを含む新しいコレクションを返す。
firstWhereメソッドは、指定した条件に一致する最初のアイテムを返す。
rejectメソッドは、filter メソッドの逆で、指定した条件を満たさないアイテムを含む新しいコレクションを返す。

### view関数の第1・第2引数の指定と何をしているか

第1引数には、表示したいbladeファイルを第一引数で指定し、第二引数に渡したいデータを[blade内での変数名 => 代入したい値]という連想配列の形で渡している。

todos という変数に格納されたデータをビュー
resources/views/todo/index.blade.php に渡して表示する処理を行っている。

第1引数には、表示したいbladeファイルを第一引数で指定し、第二引数に渡したいデータを[blade内での変数名 => 代入したい値]という連想配列の形で渡している。
第１引数の値はstring型で、第2引数のデータ型はarray型となっている。


### index.blade.phpの$todos・$todoに代入されているものは何か
$todosには、Controllerにて取得したCollectionインスタンスが代入されている。
foreachを使うことにより、Collectionインスタンスに格納されているTodoインスタンスを一つずつ$todoとして取り出している。



## Todo作成機能

### Requestクラスのallメソッドは何をしているか
Requestクラスの->all()を使用して、フォームから送信された値を個別ではなく一括で取得している。
allメソッドで取得されたデータは、Illuminate\Database\Eloquent\Collectionクラスのインスタンスでarray型。


### fillメソッドは何をしているか
->fill()を使用して、Todoインスタンスの各プロパティに一括で代入している。
->fill()は$todo->{連想配列のkey} = {連想配列のvalue}を配列の全ての要素に対して行う。

### $fillableは何のために設定しているか

->fill()によってModelに代入可能なプロパティを記述するため。
便利な一括代入には実は脆弱性があり、対策をせずに使用すると悪意のあるユーザに攻撃されてしまう恐れがあるため。


### saveメソッドで実行しているSQLは何か
 Todoインスタンスの->save()を実行してオブジェクトの状態をDBに保存するINSERT文を実行

### redirect()->route()は何をしているか
ToDoが新規作成された後に、白い画面ではなく一覧画面を表示させたいので、一覧画面にリダイレクトする処理を実装している。



## その他

### テーブル構成をマイグレーションファイルで管理するメリット
QLを知らなくても、PHPコードでテーブル操作ができるため学習コストが不要
現在のデータベースの状態を他の開発者に共有することができる

### マイグレーションファイルのup()、down()は何のコマンドを実行した時に呼び出されるのか
up() メソッドは、php artisan migrate コマンドで、マイグレーションを実行（適用）する際に呼び出される
down() メソッドは、php artisan migrate:rollback コマンドで、マイグレーションをロールバック（取り消し）する際に呼び出される

取り消し処理を用意する理由
変更を元に戻せるようにするためです。
万が一のミスや変更の取り消しが必要な場合に、手動でデータベースを修正する必要がなくなります。
例えば、新しいテーブルを作成した後、そのテーブルを削除する必要が出た場合に、down() メソッドで簡単に削除処理が行えるようになります。

### Seederクラスの役割は何か
データベースに初期データ（ダミーデータやテストデータなど）を挿入すること。

SQLを知らなくても、PHPコードでテーブル操作ができるため学習コストが不要
シーダーファイルをgit管理することで、テストデータを開発者間で共有できる


### route関数の引数・返り値・使用するメリット
Blade内のURLの記述が簡潔になり可読性が向上する。
また、URLに変更がある場合でも、ルート名さえ変わらなければ修正箇所はweb.phpのみで済むため、保守性も向上。

### @extends・@section・@yieldの関係性とbladeを分割するメリット
@extends:
親テンプレート（レイアウト）を指定。
子テンプレートが親テンプレートの構造を継承できるようにする。

@section:
親テンプレートで定義したプレースホルダ部分（@yield）を埋める内容を指定。
セクション名を指定して、その部分を動的に上書き。

@yield:
親テンプレートで定義したプレースホルダの位置に、子テンプレートで指定された内容を表示。
セクション名を指定して、その位置に対応する内容を表示。

bladeを分割するメリット
コードの再利用性の向上: 共通部分を再利用でき、変更が一箇所で済む。
可読性の向上: 各テンプレートの役割が明確になり、コードが読みやすくなる。
保守性の向上: コードの変更が他に与える影響を最小限に抑えられる。
パフォーマンスの最適化: 必要な部分だけを動的に読み込むことができ、効率的に表示。
コンポーネントの利用: Bladeコンポーネントで再利用可能な部分ビューを作成できる。
テストとデバッグの容易さ: 個別のビューやコンポーネントごとにテストができ、エラーの特定がしやすくなる。

### @csrfは何のための記述か
@csrf ディレクティブは、フォーム内に 隠しフィールド を挿入し、そこに CSRFトークンを埋め込むために使用される。
このトークンは、フォーム送信時にサーバー側でリクエストが正当であることを検証するために使われる。
CSRF対策のためのトークンが含まれたinputタグが生成されている。
input type="hidden" name="_token" value="LZbo3MlrlFzHjmYHYiKw1Q9rxSpFvfB9LYZMWhPE"

### {{ }}とは何の省略系か
{{ }} は、htmlspecialchars (変換対象, ENT_QUOTES)の省略形でエスケープ処理を行っている。
つまり、{{ }} は「変数や式をエスケープして表示する」という処理を行うため、出力される内容が自動的に HTML エスケープされる。
これにより、XSS（クロスサイトスクリプティング）攻撃を防ぐことができる。

